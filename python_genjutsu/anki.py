import genanki

# Define the deck
deck = genanki.Deck(
    deck_id=1234567891,
    name="Distributed Systems Concepts Cloze Deletion"
)

# Define the model for cloze deletion cards
cloze_model = genanki.Model(
    model_id=987654322,
    name="Cloze Model",
    fields=[
        {"name": "Text"},
        {"name": "Extra"},
    ],
    templates=[
        {
            "name": "Cloze",
            "qfmt": "{{cloze:Text}}",
            "afmt": "{{cloze:Text}}<br><br>{{Extra}}",
        },
    ],
    css=".card { font-family: arial; font-size: 20px; text-align: left; color: black; background-color: white; }"
)

# Define the cards content
cards = [
"The {{c1::two-pointer technique}} uses two pointers to traverse a data structure, often from opposite ends.",
 "The two-pointer technique is used in problems like {{c1::Valid Palindrome}} and {{c2::Strobogrammatic Number}}.",
 "The time complexity of the two-pointer approach is {{c1::O(h)}} in the worst case, where h represents the tree's height.",
 "The space complexity of the two-pointer approach is {{c1::O(1)}} due to constant space usage.",
 "In the two-pointer technique, the pointers often move toward the {{c1::center}} to compare mirrored parts.",
 "The backtracking algorithm explores all possible {{c1::combinations}} of solutions.",
 "Backtracking is used in solving {{c1::Sudoku}} and the {{c2::N-Queens puzzle}}.",
 "The time complexity of backtracking is often {{c1::exponential}} or {{c2::factorial}}.",
 "In backtracking, if a solution is not valid, the algorithm {{c1::backtracks}} to explore other paths.",
 "Backtracking can be implemented using {{c1::recursion}} to explore paths.",
 "Greedy algorithms make {{c1::locally optimal choices}} to achieve a global solution.",
 "The {{c1::Fractional Knapsack}} problem is a classic example of greedy algorithms.",
 "Dijkstra's algorithm finds the shortest path using the {{c1::greedy}} approach.",
 "Greedy algorithms do not reconsider {{c1::previous choices}} once made.",
 "The {{c1::Huffman coding}} algorithm uses a greedy approach for data compression.",
 "Graphs can be represented using {{c1::adjacency matrices}} or {{c2::adjacency lists}}.",
 "An adjacency matrix is a 2D array where each entry represents the {{c1::weight}} of an edge.",
 "The transpose of a graph involves reversing the {{c1::direction}} of all its edges.",
 "The time complexity for operations on a monotonic stack is {{c1::O(N)}}.",
 "A monotonic stack maintains elements in {{c1::increasing}} or {{c2::decreasing}} order.",
 "Recursion is used to represent a problem in terms of {{c1::smaller subproblems}}.",
 "The base case in recursion stops the {{c1::recursive calls}}.",
 "Backtracking builds solutions by exploring all possible {{c1::choices}}.",
 "The {{c1::Euclidean algorithm}} is a method to compute the GCD efficiently.",
 "The LCM of two numbers is calculated using the formula {{c1::(a * b) / GCD(a, b)}}.",
 "Stacks follow the {{c1::Last-In, First-Out (LIFO)}} principle.",
 "The push operation in a stack adds an element to the {{c1::top}}.",
 "The pop operation in a stack removes the {{c1::top element}}.",
 "The {{c1::infix}} notation places operators between operands.",
 "Postfix notation places operators {{c1::after}} their operands.",
 "The two-pointer approach is used in finding the {{c1::Lowest Common Ancestor}} in binary trees.",
 "The height of a binary tree is denoted as {{c1::h}}, which determines traversal complexity.",
 "Topological sorting orders vertices in a {{c1::Directed Acyclic Graph (DAG)}}.",
 "A DAG is a graph with no {{c1::cycles}} and all edges directed.",
 "The result of topological sorting is a {{c1::linear order}} of vertices.",
 "Depth-first search (DFS) is a method to implement {{c1::topological sorting}}.",
 "Kahn's algorithm uses {{c1::Breadth-First Search (BFS)}} for topological sorting.",
 "The {{c1::Transpose Graph}} algorithm reverses the direction of edges.",
 "In graph terminology, vertices are also known as {{c1::nodes}}.",
 "The shortest path problem in graphs can be solved using {{c1::Dijkstra's algorithm}}.",
 "The maximum area of a histogram can be determined using a {{c1::monotonic stack}}.",
 "Backtracking solves constraint satisfaction problems like {{c1::graph coloring}}.",
 "Recursion is often used in divide-and-conquer algorithms like {{c1::merge sort}}.",
 "Heaps maintain the {{c1::heap property}} during insertion and deletion.",
 "A heap can be represented using a {{c1::binary tree}} structure.",
 "Heap sort involves repeatedly removing the {{c1::largest element}} from a heap.",
 "In adjacency lists, each vertex has a list of its {{c1::neighbors}}.",
 "The {{c1::Valid Parentheses}} problem uses a stack to verify balanced expressions.",
 "The {{c1::Word Break}} problem uses backtracking and memoization for efficiency.",
 "Memoization stores intermediate results to improve {{c1::efficiency}}.",
 "The {{c1::Strobogrammatic Number}} problem determines if a number looks the same when rotated 180 degrees.",
 "In the {{c1::Next Palindrome}} problem, a two-pointer approach is used to find the next lexicographical palindrome.",
 "Greedy algorithms often fail for problems requiring {{c1::global optimization}} beyond local choices.",
 "The {{c1::Minimum Spanning Tree}} can be found using Prim's or Kruskal's algorithm.",
 "{{c1::Topological sorting}} is used to resolve dependency problems like task scheduling.",
 "The time complexity for the adjacency matrix representation is {{c1::O(V^2)}}, where V is the number of vertices.",
 "A {{c1::directed edge}} in a graph points from one vertex to another.",
 "The {{c1::breadth}} of a tree refers to the number of nodes at a specific depth.",
 "A {{c1::binary heap}} is a binary tree satisfying the heap property.",
 "In a {{c1::min-heap}}, the smallest element is always at the root.",
 "The {{c1::Tennis Court Oath}} was a key event during the French Revolution.",
 "A {{c1::cycle}} in a graph involves returning to the same vertex through a sequence of edges.",
 "The {{c1::monotonic stack}} can solve the Next Greater Element problem efficiently.",
 "The {{c1::Longest Path}} in a Directed Acyclic Graph can be found using topological sorting.",
 "{{c1::Dynamic Programming}} is often combined with recursion to solve optimization problems.",
 "The {{c1::Euclidean algorithm}} uses modulo operation for efficient GCD computation.",
 "{{c1::Greedy algorithms}} cannot solve problems that require looking ahead multiple steps.",
 "{{c1::Recursion}} requires a base case to avoid infinite calls.",
 "Backtracking systematically explores the {{c1::state-space tree}} of a problem.",
 "A {{c1::bipartite graph}} can be divided into two sets with no edges within the same set.",
 "Adjacency lists are more {{c1::space-efficient}} for sparse graphs.",
 "Heapify is used to maintain the {{c1::heap property}}.",
 "{{c1::Memoization}} stores results of function calls to avoid redundant computation.",
 "{{c1::Strobogrammatic pairs}} include 6 and 9, as well as 0 and 8.",
 "{{c1::Dynamic arrays}} grow in size automatically to accommodate elements.",
 "The {{c1::LIFO}} principle applies to stack data structures.",
 "{{c1::Queues}} follow the First-In, First-Out (FIFO) principle.",
 "The {{c1::Word Break}} problem checks if a string can be segmented into dictionary words.",
 "{{c1::Dynamic programming}} uses overlapping subproblems for efficiency.",
 "{{c1::Graph coloring}} uses backtracking to assign colors to vertices.",
 "A {{c1::Hamiltonian path}} visits every vertex exactly once.",
 "{{c1::Memoization}} transforms exponential-time recursive solutions into polynomial-time.",
 "The {{c1::Breadth-First Search (BFS)}} explores vertices level by level.",
 "{{c1::Depth-First Search (DFS)}} explores as far along a branch as possible before backtracking.",
 "A {{c1::priority queue}} uses a heap to manage elements with priority.",
 "The {{c1::Fibonacci sequence}} can be solved efficiently using memoization.",
 "{{c1::Divide-and-conquer}} algorithms split problems into subproblems, solve them recursively, and combine solutions.",
 "The {{c1::Nth term}} of a triangular series is given by n(n+1)/2.",
 "In adjacency matrices, the entry (i, j) represents the {{c1::edge weight}} between vertices i and j.",
 "{{c1::Graph transposition}} is critical for finding strongly connected components.",
 "{{c1::Dynamic programming}} is used in the Longest Increasing Subsequence problem.",
 "The {{c1::Knapsack problem}} can be solved using dynamic programming or greedy methods.",
 "{{c1::Kruskal's algorithm}} builds the minimum spanning tree by adding edges in order of weight.",
 "{{c1::Prim's algorithm}} starts from a vertex and grows the MST by adding the smallest edge.",
 "The {{c1::Shortest Path Faster Algorithm (SPFA)}} is an optimization over Bellman-Ford.",
 "A {{c1::queue}} is used for level-order traversal in trees.",
 "{{c1::Union-Find}} is used for cycle detection in graphs.",
 "A {{c1::binary search tree}} maintains sorted elements for efficient retrieval.",
 "The {{c1::merge sort}} algorithm has a time complexity of O(n log n).",
 "{{c1::Quick sort}} uses partitioning for sorting arrays.",
 "The {{c1::N-Queens problem}} places queens on a chessboard without conflicts.",
 "The {{c1::Rat in a Maze}} problem uses backtracking to find a path.",
 "The {{c1::Knights Tour}} problem ensures every square is visited exactly once.",
 "Topological sorting is useful in {{c1::course scheduling}} problems.",
 "The {{c1::Fractional Knapsack}} problem allows breaking items into fractions.",
 "{{c1::Huffman coding}} constructs an optimal binary tree for data compression.",
 "A {{c1::stack}} is used for reversing strings.",
 "{{c1::Backtracking}} finds solutions incrementally, rejecting invalid paths.",
 "{{c1::Dynamic programming}} solves problems by combining solutions to subproblems.",
 "The {{c1::BFS algorithm}} is used to find the shortest path in unweighted graphs.",
 "The {{c1::DFS algorithm}} is used to detect cycles in graphs.",
 "The {{c1::Topological Sort}} can identify task execution order.",
 "{{c1::Adjacency lists}} are used for space-efficient graph storage.",
 "{{c1::Backtracking}} is key for constraint satisfaction problems.",
 "{{c1::Monotonic stacks}} optimize solutions for range-based problems.",
 "A {{c1::heap}} is used to implement priority queues.",
 "The {{c1::Binary Search Tree}} supports operations like insertion and deletion in O(log n).",
 "A {{c1::trie}} stores strings efficiently for prefix searches.",
 "{{c1::Graphs}} model relationships using vertices and edges.",
 "A {{c1::directed acyclic graph}} is essential for topological sorting.",
 "Dynamic programming uses a {{c1::bottom-up}} approach for efficiency.",
 "{{c1::Breadth-First Search}} is ideal for shortest path problems in unweighted graphs.",
 "A {{c1::stack}} can evaluate postfix expressions.",
 "{{c1::Queues}} support operations like enqueue and dequeue.",
 "{{c1::Two-pointer techniques}} compare elements in sorted arrays.",
 "{{c1::Graph traversals}} explore all vertices and edges systematically.",
 "The {{c1::DFS algorithm}} uses recursion or a stack for implementation.",
 "{{c1::Union-Find}} detects connected components in graphs.",
 "{{c1::Graph coloring}} assigns colors to vertices with no two adjacent vertices sharing the same color.",
 "A {{c1::queue}} is ideal for handling BFS traversal.",
 "{{c1::Dynamic programming}} uses overlapping subproblems to optimize solutions.",
 "{{c1::Memoization}} prevents redundant calculations in recursion.",
 "The {{c1::KMP algorithm}} is efficient for pattern matching in strings.",
 "The {{c1::Boyer-Moore algorithm}} uses heuristics for string matching.",
 "{{c1::Huffman coding}} assigns variable-length codes for characters based on frequency.",
 "The {{c1::Heap Sort}} algorithm organizes data using a heap.",
 "{{c1::Graph adjacency matrices}} provide a dense representation.",
 "Graphs can be stored using {{c1::lists}} or {{c2::matrices}}.",
 "{{c1::Heapify}} organizes elements to maintain the heap structure.",
 "The {{c1::Union-Find}} algorithm checks if nodes are in the same set.",
 "The {{c1::Kruskal's algorithm}} builds an MST using edge weights.",
 "The {{c1::Fractional Knapsack}} problem uses a greedy algorithm.",
 "{{c1::Depth-first traversal}} is ideal for exploring all paths in a graph.",
 "The {{c1::Transpose of a graph}} reverses all edge directions.",
 "{{c1::Dynamic programming}} is useful for solving the longest common subsequence problem.",
 "A {{c1::trie}} is efficient for storing dictionaries.",
 "The {{c1::Knapsack problem}} has variations like 0/1 and fractional.",
 "{{c1::Dynamic programming}} solves overlapping subproblem challenges.",
 "A {{c1::queue}} is suitable for BFS traversal.",
 "{{c1::Graph adjacency lists}} provide space efficiency for sparse graphs.",
 "The {{c1::Kosaraju's algorithm}} is used to find strongly connected components in a graph by using {{c2::two DFS traversals}}.",
 "The {{c1::Floyd-Warshall algorithm}} computes the shortest paths between all pairs of nodes in {{c2::O(V^3)}} time.",
 "The {{c1::Bellman-Ford algorithm}} can detect and handle {{c2::negative weight cycles}} in graphs.",
 "{{c1::Tarjan’s algorithm}} finds strongly connected components in {{c2::O(V + E)}} time.",
 "{{c1::Dijkstra's algorithm}} cannot handle {{c2::negative weights}} because it assumes distances can only decrease.",
 "The {{c1::A* algorithm}} uses heuristics to optimize {{c2::pathfinding}} in graphs.",
 "In the {{c1::Ford-Fulkerson method}}, the maximum flow problem is solved using the concept of {{c2::augmenting paths}}.",
 "A graph is {{c1::Eulerian}} if all vertices have {{c2::even degrees}}.",
 "The {{c1::Hopcroft-Karp algorithm}} finds the maximum matching in bipartite graphs in {{c2::O(E√V)}} time.",
 "The {{c1::Edmonds-Karp algorithm}} is an implementation of Ford-Fulkerson that uses {{c2::BFS}} to find augmenting paths.",
 "The {{c1::Longest Increasing Subsequence (LIS)}} problem can be solved in {{c2::O(n log n)}} using binary search.",
 "The {{c1::Z-algorithm}} efficiently finds all occurrences of a pattern in a string in {{c2::O(n)}} time.",
 "The {{c1::Suffix Array}} is used for efficient {{c2::pattern matching}} in large texts.",
 "{{c1::Fenwick Trees}} efficiently compute prefix sums and updates in {{c2::O(log n)}}.",
 "The {{c1::Segment Tree}} is a versatile data structure for range queries and updates in {{c2::O(log n)}} time.",
 "The {{c1::KMP algorithm}} avoids redundant comparisons by preprocessing the {{c2::partial match table}}.",
 "The {{c1::Rabin-Karp algorithm}} uses {{c2::hashing}} for efficient string matching.",
 "The {{c1::Manacher's algorithm}} finds the longest palindromic substring in {{c2::O(n)}} time.",
 "The {{c1::Disjoint Set Union (DSU)}} supports union and find operations in {{c2::O(α(n))}}, where α is the inverse Ackermann function.",
 "The {{c1::Mo's algorithm}} answers offline range queries in {{c2::O((n + q)√n)}}.",
 "The {{c1::Treap}} is a randomized binary search tree that maintains a {{c2::heap property}} based on priority.",
 "The {{c1::Splay Tree}} is a self-adjusting binary search tree optimized for {{c2::frequently accessed elements}}.",
 "{{c1::Persistent Segment Trees}} allow access to all previous versions of the tree in {{c2::O(log n)}}.",
 "The {{c1::Heavy-Light Decomposition}} is used for path queries in trees in {{c2::O(log^2 n)}}.",
 "The {{c1::Centroid Decomposition}} is used to optimize divide-and-conquer algorithms on trees for {{c2::query efficiency}}.",
 "{{c1::FFT (Fast Fourier Transform)}} multiplies polynomials efficiently in {{c2::O(n log n)}}.",
 "{{c1::Suffix Trees}} solve substring queries in {{c2::O(m)}} time, where m is the pattern length.",
 "The {{c1::Convex Hull}} problem can be solved using {{c2::Graham's scan}} or {{c3::Jarvis march}}.",
 "The {{c1::Divide-and-Conquer Convex Hull}} algorithm has a time complexity of {{c2::O(n log n)}}.",
 "The {{c1::Trie}} data structure supports {{c2::efficient prefix matching}} in text processing.",
 "The {{c1::Dynamic Programming on Trees}} technique solves problems like {{c2::maximum path sum}} in {{c3::O(n)}} time.",
 "The {{c1::Floyds Cycle Detection Algorithm}} detects cycles in linked lists using {{c2::two pointers}}.",
 "The {{c1::Josephus problem}} is solved efficiently using {{c2::modular arithmetic}}.",
 "The {{c1::Sparse Table}} supports range minimum queries (RMQ) in {{c2::O(1)}} after {{c3::O(n log n)}} preprocessing.",
 "{{c1::Euler's totient function}} calculates the count of integers up to n that are {{c2::relatively prime}} to n.",
 "The {{c1::Chinese Remainder Theorem}} solves simultaneous congruences in modular arithmetic.",
 "The {{c1::Extended Euclidean Algorithm}} finds integer coefficients that satisfy {{c2::Bezouts identity}}.",
 "The {{c1::Biconnected Components}} of a graph can be found using {{c2::DFS}} in {{c3::O(V + E)}} time.",
 "The {{c1::2-SAT problem}} can be solved in linear time using {{c2::implication graphs}} and strongly connected components.",
 "The {{c1::Kadane's algorithm}} finds the maximum sum subarray in {{c2::O(n)}} time.",
 "The {{c1::Tree Isomorphism}} problem determines if two trees are {{c2::structurally identical}}.",
 "{{c1::DAG shortest paths}} can be found in {{c2::O(V + E)}} using topological sorting.",
 "The {{c1::Meet-in-the-Middle}} technique is used to solve problems with constraints around {{c2::exponential search space}}.",
 "{{c1::Trie with Bitmasking}} optimizes search for unique prefixes in binary data.",
 "The {{c1::Maximum Flow}} in a graph can be solved using the {{c2::Dinic's algorithm}} in {{c3::O(V^2E)}}.",
 "The {{c1::Miller-Rabin test}} is a probabilistic algorithm to check if a number is {{c2::prime}}.",
 "The {{c1::Karatsuba algorithm}} multiplies two numbers faster than standard methods with a complexity of {{c2::O(n^log2(3))}}.",
 "{{c1::Matrix exponentiation}} solves recurrence relations in {{c2::logarithmic time}}.",
 "The {{c1::Bitmask Dynamic Programming}} technique is used to solve the {{c2::Traveling Salesman Problem}}.",
 "{{c1::Heavy-Light Decomposition}} is combined with segment trees for efficient {{c2::range queries}} on paths.",


]

# Add cards to the deck
for card in cards:
    note = genanki.Note(
        model=cloze_model,
        fields=[card, ""],
    )
    deck.add_note(note)

# Generate the .apkg file
output_file = "codingPatterns.apkg"
genanki.Package(deck).write_to_file(output_file)

print(f"Deck created: {output_file}")
